// Generated by CoffeeScript 1.9.3
(function() {
  var Backbone, Clock, ClockListener, Direction, Field, Game, Point, State, StatesFromTags, _, decorators, helpers,
    slice = [].slice;

  Backbone = require('backbone4000/extras');

  _ = require('underscore');

  helpers = require('helpers');

  decorators = require('decorators');

  ClockListener = exports.ClockListener = Backbone.Model.extend4000({
    "in": function(n, callback) {
      if (!(this.clockParent.tick + n)) {
        throw new Error("clocklistener doesn't have a parent", n, this.name);
      }
      return this.listenToOnceOff(this.clockParent, 'tick_' + (this.clockParent.tick + n), callback);
    },
    onTick: function(n, callback) {
      return this.listenToOnceOff(this.clockParent, 'tick_' + n, callback);
    },
    nextTick: function(callback) {
      return this["in"](1, callback);
    },
    eachTick: function(callback) {
      return this.listenTo(this.clockParent, 'tick', callback);
    },
    getTick: function() {
      return this.clockParent.tick;
    }
  });

  Clock = exports.Clock = ClockListener.extend4000({
    initialize: function(options) {
      this.clockParent = this;
      return _.extend(this, {
        tickspeed: 50,
        tick: 0
      }, this.get('options') || {}, options);
    },
    dotick: function() {
      this.tick++;
      this.trigger('tick', this.tick);
      return this.trigger('tick_' + this.tick);
    },
    tickloop: function() {
      this.timeout = setTimeout(this.tickloop.bind(this), this.tickspeed);
      return this.dotick();
    },
    stopTickloop: function() {
      return clearTimeout(this.timeout);
    },
    getTick: function() {
      return this.tick;
    }
  });

  StatesFromTags = function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    args = _.map(args, (function(_this) {
      return function(arg) {
        if (arg.constructor === String) {
          return _this.find(arg);
        } else {
          return arg;
        }
      };
    })(this));
    args = _.flatten(args);
    return f.apply(this, args);
  };

  exports.State = State = Backbone.Tagged.extend4000(ClockListener, {
    initialize: function() {
      return this.when('point', (function(_this) {
        return function(point) {
          _this.point = point;
          _this.on('change:point', function(model, point) {
            return _this.point = point;
          });
          _this.clockParent = point.game;
          if (!_this.id) {
            _this.id = _this.get('id');
          }
          if (!_this.id) {
            _this.set({
              id: _this.id = point.game.nextid()
            });
          }
          point.game.byid[_this.id] = _this;
          if (_this.start) {
            return _this.start();
          }
        };
      })(this));
    },
    sound: function(name) {
      return this.point.game.sound(this, name);
    },
    place: function() {
      var states;
      states = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.point.push.apply(this.point, states);
    },
    replace: function(state) {
      this.remove();
      return this.point.push(state);
    },
    move: function(where) {
      return this.point.move(this, where);
    },
    remove: function() {
      this.point.remove(this);
      return delete this.point.game.byid[this.id];
    },
    cancel: function(callback) {
      return this.point.game.off(null, callback);
    },
    each: function(callback) {
      return callback(this.name);
    },
    msg: function(msg) {
      if (msg == null) {
        msg = {};
      }
      return this.point.game.trigger('message', this, msg);
    },
    show: function() {
      return this.name;
    },
    render: function() {
      if (this.repr) {
        return this.repr;
      } else {
        return _.first(this.name);
      }
    }
  });

  exports.Point = Point = Backbone.Tagged.extend4000(ClockListener, {
    initialize: function(arg1, game) {
      this.x = arg1[0], this.y = arg1[1];
      this.game = game;
      this.clockParent = this.game;
      this.tags = {};
      this.states = new Backbone.Collection();
      if (!this.id) {
        this.id = this.get('id');
      }
      if (!this.id) {
        this.set({
          id: this.id = this.game.getIndex(this)
        });
      }
      this.states.on('add', (function(_this) {
        return function(state) {
          _this._addstate(state);
          return _this.trigger('set', state);
        };
      })(this));
      this.states.on('remove', (function(_this) {
        return function(state) {
          _this._delstate(state);
          state.trigger('del');
          return _this.trigger('del', state);
        };
      })(this));
      this.on('move', (function(_this) {
        return function(state) {
          return _this._addstate(state);
        };
      })(this));
      this.on('moveaway', (function(_this) {
        return function(state) {
          return _this._delstate(state);
        };
      })(this));
      this.states.on('addTag', (function(_this) {
        return function(tag) {
          return _this._addTag(tag);
        };
      })(this));
      this.states.on('delTag', (function(_this) {
        return function(tag) {
          return _this._delTag(tag);
        };
      })(this));
      this.on('del', (function(_this) {
        return function(state) {
          return _this.game.trigger('del', state, _this);
        };
      })(this));
      this.on('set', (function(_this) {
        return function(state) {
          return _this.game.trigger('set', state, _this);
        };
      })(this));
      return this.on('move', (function(_this) {
        return function(state, from) {
          return _this.game.trigger('move', state, _this, from);
        };
      })(this));
    },
    _addstate: function(state) {
      this.game.push(this);
      state.set({
        point: this
      });
      return _.map(state.tags, (function(_this) {
        return function(v, tag) {
          return _this._addTag(tag);
        };
      })(this));
    },
    _delstate: function(state) {
      if (!this.states.length) {
        this.game.remove(this);
      }
      return _.map(state.tags, (function(_this) {
        return function(v, tag) {
          return _this._delTag(tag);
        };
      })(this));
    },
    _addTag: function(tag) {
      if (!this.tags[tag]) {
        this.tags[tag] = 1;
        this.trigger('addTag', tag);
        return this.trigger('addTag:' + tag, this);
      } else {
        return this.tags[tag]++;
      }
    },
    _delTag: function(tag) {
      this.tags[tag]--;
      if (this.tags[tag] === 0) {
        delete this.tags[tag];
        this.trigger('delTag', tag);
        return this.trigger('delTag:' + tag, this);
      }
    },
    modifier: function(coords) {
      if (coords.constructor !== Array) {
        coords = coords.coords();
      }
      return this.game.point([this.x + coords[0], this.y + coords[1]]);
    },
    direction: function(direction) {
      return this.modifier(direction);
    },
    find: function(tag) {
      return this.states.find(function(state) {
        return state.tags[tag];
      });
    },
    filter: function(tag) {
      return this.states.filter(function(state) {
        return state.tags[tag];
      });
    },
    up: function() {
      return this.modifier([0, -1]);
    },
    down: function() {
      return this.modifier([0, 1]);
    },
    left: function() {
      return this.modifier([-1, 0]);
    },
    right: function() {
      return this.modifier([1, 0]);
    },
    upRight: function() {
      return this.modifier([1, -1]);
    },
    upLeft: function() {
      return this.modifier([-1, -1]);
    },
    downRight: function() {
      return this.modifier([1, 1]);
    },
    downLeft: function() {
      return this.modifier([-1, 1]);
    },
    distance: function(point) {
      if (!point) {
        return Infinity;
      }
      return Math.abs(point.x - this.x) + Math.abs(point.y - this.y);
    },
    randomWalk: function() {
      return this.modifier([h.random([-1, 0, 1]), h.random([-1, 0, 1])]);
    },
    outside: function() {
      if ((this.x < 0) || (this.y < 0)) {
        return true;
      }
      if ((this.y > this.game.get('height')) || (this.x > this.game.get('width'))) {
        return true;
      }
      return false;
    },
    coords: function() {
      return [this.x, this.y];
    },
    add: function(state, options) {
      if (state.constructor === String) {
        state = new this.game.state[state];
      }
      this.states.add(state, options);
      return this;
    },
    dir: function() {
      return this.states.map(function(state) {
        return state.name;
      });
    },
    dirtags: function() {
      return _.keys(this.tags);
    },
    push: function(state, options) {
      return this.add(state, options);
    },
    map: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.states.map.apply(this.states, args);
    },
    each: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.states.each.apply(this.states, args);
    },
    empty: function() {
      return helpers.isEmpty(this.models);
    },
    tagmap: function(callback) {
      return _.map(this.tags, function(n, tag) {
        return callback(tag);
      });
    },
    remove: decorators.decorate(StatesFromTags, function() {
      var states;
      states = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return _.map(states, (function(_this) {
        return function(state) {
          return _this.states.remove(state);
        };
      })(this));
    }),
    removeall: function() {
      var results;
      results = [];
      while (this.states.pop()) {
        results.push(true);
      }
      return results;
    },
    move: function(state, where) {
      this.states.remove(state, {
        silent: true
      });
      if (where.constructor !== Point) {
        if (where.constructor === Direction) {
          where = this.modifier(where);
        }
        if (where.constructor === Array) {
          where = this.game.point(where);
        }
      }
      where.push(state, {
        silent: true
      });
      where.trigger('move', state, this);
      state.trigger('move', where);
      return this.trigger('moveaway', state, where);
    },
    show: function() {
      return this.states.map(function(state) {
        return state.show();
      });
    },
    render: function() {
      var state;
      if (state = this.states.last()) {
        return state.render();
      } else {
        return ".";
      }
    }
  });

  exports.Field = Field = Backbone.Model.extend4000({
    initialize: function() {
      var pointDecorator;
      this.points = {};
      pointDecorator = (function(_this) {
        return function() {
          var args, fun;
          fun = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (args[0].constructor !== Point) {
            args[0] = _this.point(args[0]);
          }
          return fun.apply(_this, args);
        };
      })(this);
      return this.getIndex = decorators.decorate(pointDecorator, this.getIndex);
    },
    point: function(point) {
      var ret;
      if (point.constructor === Array) {
        point = new Point(point, this);
      }
      if (ret = this.points[point.id]) {
        return ret;
      } else if (point.game === this) {
        return point;
      } else {
        return new Point(point.coords(), this);
      }
    },
    remove: function(point) {
      if (point) {
        return delete this.points[this.getIndex(point)];
      }
    },
    push: function(point) {
      return this.points[this.getIndex(point)] = point;
    },
    getIndex: function(point) {
      return point.x + (point.y * this.get('width'));
    },
    getIndexRev: function(i) {
      var width;
      width = this.get('width');
      return [i % width, Math.floor(i / width)];
    },
    map: function(callback) {
      var ret;
      ret = [];
      this.each(function(data) {
        return ret.push(callback(data));
      });
      return ret;
    },
    eachFull: function(callback) {
      return this.map(callback);
    },
    each: function(callback) {
      return _.times(this.get('width') * this.get('height'), (function(_this) {
        return function(i) {
          return callback(_this.point(_this.getIndexRev(i)));
        };
      })(this));
    },
    show: function(callback) {
      return helpers.dictMap(this.points, function(point, index) {
        return point.show();
      });
    },
    render: function() {
      var colorFlip, colors, data, flip;
      colors = require('colors');
      data = "    ";
      flip = false;
      colorFlip = function(text) {
        if (flip) {
          flip = false;
          return colors.yellow(text);
        } else {
          flip = true;
          return colors.green(text);
        }
      };
      _.times(this.get('width'), (function(_this) {
        return function(y) {
          return data += colorFlip(helpers.pad(y, 2, '0'));
        };
      })(this));
      data += "  x (width)\n\n";
      _.times(this.get('height'), (function(_this) {
        return function(y) {
          var row;
          row = [' '];
          _.times(_this.get('width'), function(x) {
            return row.push(_this.point([x, y]).render());
          });
          return data += colorFlip(helpers.pad(y, 2, '0')) + " " + row.join(' ') + "\n";
        };
      })(this));
      data += "\ny (height)\n";
      return data;
    }
  });

  exports.Game = Game = Field.extend4000(Clock, {
    initialize: function() {
      this.controls = {};
      this.state = {};
      this.tick = 0;
      this.stateid = 1;
      this.ended = false;
      return this.byid = {};
    },
    sound: function(state, name) {
      return this.trigger('sound', state, name);
    },
    nextid: function(state) {
      return this.stateid++;
    },
    stop: function() {
      return this.end();
    },
    end: function(data) {
      this.stopTickloop();
      if (!this.ended) {
        this.trigger('end', data);
      }
      return this.ended = true;
    },
    start: function(options, callback) {
      if (options == null) {
        options = {};
      }
      if (this.ended) {
        callback('This game has already ended');
        return;
      }
      _.extend(this, options);
      this.tickloop();
      return this.on('end', (function(_this) {
        return function(data) {
          return helpers.cbc(callback, data);
        };
      })(this));
    },
    defineMover: function() {
      var definitions, name;
      name = arguments[0], definitions = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return defineState([name].concat(mover, definitions));
    },
    defineState: function() {
      var definitions, initialize, lastdef, name, start;
      definitions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      lastdef = {};
      if (_.first(definitions).constructor === String) {
        lastdef.name = name = definitions.shift();
      } else {
        name = _.last(definitions).name;
      }
      lastdef.tags = {};
      lastdef.tags[name] = true;
      start = [];
      initialize = [];
      _.map(definitions, function(definition) {
        if (definition.start) {
          start.push(definition.start);
        }
        if (definition.initialize) {
          initialize.push(definition.initialize);
        }
        return helpers.maybeiterate(definition.tags, function(tag, v) {
          if (tag) {
            return lastdef.tags[tag] = true;
          }
        });
      });
      lastdef.start = helpers.joinF.apply(this, start);
      definitions.push(lastdef);
      return this.state[name] = State.extend4000.apply(State, definitions);
    }
  });

  exports.Direction = Direction = Direction = (function() {
    function Direction(x1, y1) {
      this.x = x1;
      this.y = y1;
      true;
    }

    Direction.prototype.reverse = function() {
      return this.x *= -1 || (this.y *= -1);
    };

    Direction.prototype.up = function() {
      return this.set(0, -1);
    };

    Direction.prototype.down = function() {
      return this.set(0, 1);
    };

    Direction.prototype.left = function() {
      return this.set(-1, 0);
    };

    Direction.prototype.right = function() {
      return this.set(1, 0);
    };

    Direction.prototype.turnLeft = function() {
      return new Direction(this.y, -this.x);
    };

    Direction.prototype.turnRight = function() {
      return new Direction(-this.y, this.x);
    };

    Direction.prototype.coords = function() {
      return [this.x, this.y];
    };

    Direction.prototype.relevant = function() {
      return function(coords) {
        if (!this.x) {
          return coords[1];
        } else {
          return coords[0];
        }
      };
    };

    Direction.prototype.set = function(x1, y1) {
      this.x = x1;
      this.y = y1;
      return this;
    };

    Direction.prototype.string = function() {
      if (this.y === -1) {
        return 'up';
      }
      if (this.y === 1) {
        return 'down';
      }
      if (this.x === -1) {
        return 'left';
      }
      if (this.x === 1) {
        return 'right';
      }
      if (!this.x && !this.y) {
        return 'stop';
      }
    };

    Direction.prototype.flip = function() {
      return new Direction(-this.x, -this.y);
    };

    Direction.prototype.stop = function() {
      if (!this.x && !this.y) {
        return true;
      } else {
        return false;
      }
    };

    Direction.prototype.horizontal = function() {
      if (this.x) {
        return true;
      } else {
        return false;
      }
    };

    Direction.prototype.vertical = function() {
      if (this.y) {
        return true;
      } else {
        return false;
      }
    };

    Direction.prototype.forward = function() {
      if (this.x > 0 || this.y > 0) {
        return true;
      } else {
        return false;
      }
    };

    Direction.prototype.backward = function() {
      if (this.x < 0 || this.y < 0) {
        return true;
      } else {
        return false;
      }
    };

    Direction.prototype.orientation = function() {
      if (this.x === 1) {
        return 'vertical';
      }
      if (this.x === -1) {
        return 'vertical';
      }
      if (this.y === -1) {
        return 'horizontal';
      }
      if (this.y === 1) {
        return 'horizontal';
      }
      if (!this.x && !this.y) {
        return 'stop';
      }
    };

    return Direction;

  })();

}).call(this);
