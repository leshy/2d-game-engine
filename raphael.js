// Generated by CoffeeScript 1.3.3
(function() {
  var $, Backbone, Color, DirectionPainter, GameView, Image, MetaPainter, OrientationPainter, RaphaelPainter, Sprite, View, coordsDecorator, decorate, decorators, helpers, raphael, v, validator, _;

  _ = require('underscore');

  helpers = require('helpers');

  Backbone = require('backbone4000');

  validator = require('validator2-extras');

  v = validator.v;

  decorators = require('decorators');

  decorate = decorators.decorate;

  $ = require('jquery-browserify');

  View = require('./views');

  raphael = require('raphael-browserify');

  coordsDecorator = function(targetf, coords) {
    if (!coords) {
      coords = this.gameview.translate(this.state.point.coords());
    }
    return targetf.call(this, coords);
  };

  GameView = exports.GameView = View.GameView.extend4000({
    initialize: function() {
      var el, sizex, sizey;
      el = this.get('el');
      this.paper = raphael(el.get(0), el.width(), el.height());
      window.paper = this.paper;
      sizey = Math.floor(this.paper.canvas.clientHeight / this.game.get('height'));
      sizex = Math.floor(this.paper.canvas.clientWidth / this.game.get('width'));
      if (sizex > sizey) {
        this.size = sizey;
      } else {
        this.size = sizex;
      }
      this.size_offsetx = Math.round((this.paper.canvas.clientWidth - (this.size * game.get('width'))) / 2);
      return this.size_offsety = Math.round((this.paper.canvas.clientHeight - (this.size * game.get('height'))) / 2);
    },
    translate: function(coords) {
      return [this.size_offsetx + (coords[0] * this.size), this.size_offsety + (coords[1] * this.size)];
    }
  });

  RaphaelPainter = View.Painter.extend4000({
    draw: function(point) {
      return this.render(this.gameview.translate(point.coords()), this.gameview.size);
    }
  });

  Image = exports.Image = RaphaelPainter.extend4000({
    stopAnimate: function() {
      return console.log('stop animating');
    },
    render: function(coords, cellSize) {
      var src, _ref, _ref1,
        _this = this;
      if (!coords) {
        coords = this.coords;
      } else {
        this.coords = coords;
      }
      if (!cellSize) {
        cellSize = this.cellSize;
      } else {
        this.cellSize = cellSize;
      }
      if (this.name === "Player") {
        console.log('player state: ', this.state);
      }
      if ((_ref = this.state) != null ? _ref.mover : void 0) {
        console.log("STATE MOVER!", coords, this.state.coordinates);
        coords = helpers.squish(coords, this.state.coordinates, function(coord, subCoord) {
          return Math.round(coord + (cellSize * (0.5 - subCoord)));
        });
        console.log('coords updated to', coords);
      }
      if (!this.rendering) {
        this.rendering = this.gameview.paper.image(src = this.getpic(), coords[0], coords[1], this.gameview.size, this.gameview.size);
        this.rendering.toFront();
        if (this.rotation) {
          this.rendering.rotate(this.rotation);
        }
        if ((_ref1 = this.state) != null ? _ref1.mover : void 0) {
          this.state.on('movementChange', function() {
            return _this.render();
          });
        }
        return;
      }
      if (this.rendering.attrs.x !== coords[0] || this.rendering.attrs.y !== coords[1]) {
        this.move(coords);
      }
      if (this.state.speed && !this.state.direction.stop()) {
        this.animate();
      } else {
        this.stopAnimate();
      }
      return this.rendering.toFront();
    },
    getpic: function() {
      return '/pic/' + (this.pic || this.name) + '.png';
    },
    move: function(coords) {
      console.log('need to move rendering to new coords', coords);
      return this.rendering.attr({
        x: coords[0],
        y: coords[1]
      });
    },
    images: function() {
      return [this.getpic()];
    },
    remove: function() {
      return this.rendering.remove();
    }
  });

  Sprite = exports.Sprite = Image.extend4000({
    initialize: function() {
      var _this = this;
      this.frame_pics = [];
      _.times(this.frames, function(frame) {
        return _this.frame_pics.push('/pic/' + (_this.pic || _this.name) + frame + ".png");
      });
      this.frame = 0;
      if (this.gameview) {
        return this.listenTo(this.gameview, 'tick', function() {
          return _this.tick();
        });
      }
    },
    getpic: function() {
      return this.frame_pics[this.frame];
    },
    remove: function() {
      this.stopListening();
      return Image.prototype.remove.call(this);
    },
    tick: function() {
      if (!this.rendering) {
        return;
      }
      if (this.frame > this.frame_pics.length - 1) {
        if (this.once) {
          this.stopListening();
          return;
        }
        this.frame = 0;
      }
      this.rendering.attr({
        src: this.getpic()
      });
      return this.frame++;
    },
    images: function() {
      return this.frame_pics;
    }
  });

  Color = exports.Color = RaphaelPainter.extend4000({
    render: decorate(coordsDecorator)
  }, function(coords) {
    return this.rendering = this.gameview.paper.rect(coords[0], coords[1], this.gameview.size, this.gameview.size).attr({
      'opacity': .7,
      'stroke-width': 1,
      stroke: this.color,
      fill: this.color
    });
  }, {
    move: decorate(coordsDecorator)
  }, function(coords) {
    return this.rendering.attr({
      x: coords[0],
      y: coords[1]
    });
  }, {
    remove: function() {
      return this.rendering.remove();
    }
  });

  MetaPainter = exports.MetaPainter = RaphaelPainter.extend4000({
    render: function(coords) {
      var cls;
      console.log("METAPAINTER RENDER", this.state, this);
      if (!this.repr) {
        cls = this.decideRepr();
        this.repr = new cls({
          gameview: this.gameview,
          state: this.state
        });
      }
      return this.repr.render(coords);
    },
    remove: function() {
      return this.repr.remove();
    },
    decideRepr: function() {
      throw 'override me';
    }
  });

  DirectionPainter = exports.DirectionPainter = MetaPainter.extend4000({
    decideRepr: function() {
      return this.reprs[this.state.get('direction').string()];
    }
  });

  OrientationPainter = exports.OrientationPainter = MetaPainter.extend4000({
    decideRepr: function() {
      return this.reprs[this.state.get('direction').orientation()];
    }
  });

}).call(this);
