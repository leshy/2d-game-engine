// Generated by LiveScript 1.4.0
(function(){
  var $, h, _, THREE, Backbone, OrbitControls, View, GameView, Painter;
  $ = require('jquery');
  h = require('helpers');
  _ = require('underscore');
  THREE = require('three');
  Backbone = require('backbone4000');
  OrbitControls = require('three-orbit-controls')(THREE);
  View = require('./views');
  GameView = exports.GameView = View.GameView.extend4000({
    setLight: function(){
      return this.light.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z);
    },
    render: function(){
      var el, camera, directionalLight, addSL, controls, render, this$ = this;
      window.gameView = this;
      el = this.get('el');
      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false
      });
      this.renderer.setClearColor(0x000000);
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapType = THREE.PCFSoftShadowMap;
      this.renderer.shadowMapSoft = true;
      this.renderer.shadowCameraNear = 0.1;
      this.renderer.shadowCameraFar = 100;
      this.renderer.shadowCameraFov = 90;
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      camera = this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 100);
      camera.position.set(8.6, -5.5, 11);
      camera.lookAt(new THREE.Vector3(8.6, -5.5, 0));
      this.el.append(this.renderer.domElement);
      this.scene = new THREE.Scene();
      directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100);
      this.scene.add(directionalLight);
      this.scene.add(new THREE.AmbientLight(0xaaaaaa));
      addSL = function(){
        var spotLight;
        spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(15, -15, 1);
        spotLight.intensity = 5;
        spotLight.castShadow = true;
        spotLight.shadowDarkness = 0.9;
        spotLight.shadowCameraVisible = true;
        spotLight.shadowMapWidth = 1024;
        spotLight.shadowMapHeight = 1024;
        spotLight.shadowCameraNear = 500;
        spotLight.shadowCameraFar = 4000;
        spotLight.shadowCameraFov = 30;
        return this$.scene.add(spotLight);
      };
      controls = new OrbitControls(camera, this.renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.target = new THREE.Vector3(8.6, -5.5, 0);
      render = function(){
        controls.update();
        this$.renderer.render(this$.scene, camera);
        return h.wait(25, function(){
          return requestAnimationFrame(render);
        });
      };
      return render();
    },
    translate: function(coords){
      coords = _.clone(coords);
      coords[1] = -coords[1];
      coords.push(1);
      return coords;
    }
  });
  Painter = View.Painter.extend4000({
    draw: function(point){
      return true;
    },
    remove: function(){
      return this.gameview.scene.remove(this.element);
    }
  });
  exports.Cube = Painter.extend4000({
    getPos: function(point){},
    draw: function(point){
      var opts, shape, geometry, position;
      if (!this.element) {
        opts = {};
        if (this.texture) {
          opts.map = this.texture;
        }
        if (this.bmap) {
          opts.bumpMap = this.bmap;
        }
        if (this.color) {
          opts.color = this.color;
        }
        shape = this.shape || [1, 1, 1];
        geometry = new THREE.BoxGeometry(shape[0], shape[1], shape[2]);
        this.element = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial(opts));
        if (this.shadow) {
          this.element.castShadow = true;
        }
        if (this.shadowR) {
          this.element.receiveShadow = true;
        }
        this.gameview.scene.add(this.element);
      }
      position = this.gameview.translate(point.coords());
      if (this.offset) {
        position = h.squish(position, this.offset, function(c1, c2){
          return c1 + c2;
        });
      }
      this.element.position.x = position[0];
      this.element.position.y = position[1];
      return this.element.position.z = position[2];
    }
  });
}).call(this);
