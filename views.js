// Generated by LiveScript 1.4.0
(function(){
  var h, Backbone, validator, v, Models, _, Painter, GameView, MultiPainter, MetaPainter, DirectionPainter, OrientationPainter, slice$ = [].slice;
  h = require('helpers');
  Backbone = require('backbone4000');
  validator = require('validator2-extras');
  v = validator.v;
  Models = require('./models');
  _ = require('underscore');
  Painter = exports.Painter = Models.ClockListener.extend4000({
    id: function(){
      if (this.state) {
        return this.state.id;
      } else {
        return this.point.coords() + '/' + this.name;
      }
    },
    initialize: function(options){
      var id, this$ = this;
      if (options === false) {
        return;
      }
      this.set(options);
      _.extend(this, options);
      this.clockParent = this.gameview;
      if (this.state) {
        this.listenToOnce(this.state, 'del', function(){
          this$.remove();
          return this$.gameview.drawPoint(this$.state.point);
        });
      } else if (this.point) {
        true;
      } else {
        throw "I didn't get a point or a state, wtf. my name is " + this.name;
      }
      id = this.id();
      h.dictpush(this.gameview.pInstances, String(id), this);
      return this.on('remove', function(){
        var ref$, ref1$;
        return ref1$ = (ref$ = this$.gameview.pInstances)[id], delete ref$[id], ref1$;
      });
    },
    draw: function(coords, size){
      throw 'not implemented';
    },
    remove: function(){
      return this.trigger('remove');
    },
    move: function(){
      throw 'not implemented';
    },
    images: function(){
      return [];
    }
  });
  GameView = exports.GameView = exports.View = Backbone.Model.extend4000(Models.Clock, {
    stop: function(){
      return this.end();
    },
    end: function(){
      if (this.game != null) {
        this.stopListening(this.game);
      }
      return this.stopTickloop();
    },
    initialize: function(){
      var this$ = this;
      this.painters = {};
      this.pInstances = {};
      return this.when('game', function(game){
        this$.game = game;
        return _.defer(function(){
          game.on('set', function(state, point){
            return this$.drawPoint(point);
          });
          game.on('del', function(state, point){
            return this$.drawPoint(point);
          });
          game.on('move', function(state, point, from){
            return this$.drawPoint(point);
          });
          game.each(function(point){
            return this$.drawPoint(point);
          });
          game.once('end', function(){
            return this$.end();
          });
          return this$.tickloop();
        });
      });
    },
    definePainter: function(){
      var definitions, name, painter;
      definitions = slice$.call(arguments);
      if (_.first(definitions).constructor === String) {
        definitions.push({
          name: name = definitions.shift()
        });
      } else {
        name = _.last(definitions).name;
      }
      this.painters[name] = painter = Backbone.Model.extend4000.apply(Backbone.Model, definitions);
      this.trigger('definePainter', painter);
      return painter;
    },
    getPainter: function(state){
      var painter, painterclass;
      if (painter = this.pInstances[state.id]) {
        return painter;
      }
      painterclass = this.painters[state.name];
      if (!painterclass) {
        painterclass = this.painters.Unknown;
      }
      return painterclass.extend4000({
        state: state
      });
    },
    specialPainters: function(painters){
      return painters;
    },
    drawPoint: function(point){
      var _applyEliminations, _sortf, _applyOrder, _instantiate, _specialPainters, painters, this$ = this;
      _applyEliminations = function(painters){
        var dict;
        dict = h.makedict(painters, function(painter){
          return h.objorclass(painter, 'name');
        });
        _.map(painters, function(painter){
          var eliminates;
          if (eliminates = h.objorclass(painter, 'eliminates')) {
            return h.maybeiterate(eliminates, function(name){
              var painter, ref$;
              painter = dict[name];
              if (typeof painter === 'object') {
                painter.remove();
              }
              return ref$ = dict[name], delete dict[name], ref$;
            });
          }
        });
        return h.makelist(dict);
      };
      _sortf = function(painter){
        return h.objorclass(painter, 'zindex');
      };
      _applyOrder = function(painters){
        return _.sortBy(painters, _sortf);
      };
      _instantiate = function(painters){
        return _.map(painters, function(painter){
          if (painter.constructor === Function) {
            return new painter({
              gameview: this$,
              point: point
            });
          } else if (painter.constructor === String) {
            return new this$.painters[painter]({
              gameview: this$,
              point: point
            });
          } else {
            return painter;
          }
        });
      };
      _specialPainters = function(painters, point){
        var existingPainters, newPainters, ref$, existingKeep, existingRemove, newAdd;
        existingPainters = this$.pInstances[String(point.coords())] || [];
        newPainters = this$.specialPainters(painters, point);
        ref$ = h.difference(existingPainters, newPainters, function(x){
          return x.name;
        }, function(x){
          return x.prototype.name;
        }), existingKeep = ref$[0], existingRemove = ref$[1], newAdd = ref$[2];
        _.each(existingRemove, function(painter){
          return painter.remove();
        });
        return painters.concat(existingKeep, newAdd);
      };
      painters = point.map(function(state){
        return this$.getPainter(state);
      });
      painters = _specialPainters(painters, point);
      painters = _applyEliminations(painters);
      painters = _applyOrder(painters);
      painters = _instantiate(painters);
      return _.map(painters, function(painter){
        return painter.draw(point);
      });
    }
  });
  MultiPainter = exports.MultiPainter = Painter.extend4000({
    initialize: function(){
      var this$ = this;
      return this.on('remove', function(){
        return this$.reprs.each(function(repr){
          return repr.remove();
        });
      });
    },
    draw: function(point){
      return this.render(this.gameview.translate(point.coords()), this.gameview.size);
    },
    render: function(){
      var args;
      args = slice$.call(arguments);
      return this.reprs.each(function(repr){
        return repr.render.apply(repr, args);
      });
    }
  });
  MetaPainter = exports.MetaPainter = Painter.extend4000({
    initialize: function(){
      var this$ = this;
      return this.on('remove', function(){
        return this$.repr.remove();
      });
    },
    reprChange: function(){
      this.repr.remove();
      delete this.repr;
      return this.draw.apply(this, this.point);
    },
    inherit: function(){
      var this$ = this;
      return h.dictFromArray(['frame'], function(attr){
        return [attr, this$[attr]];
      });
    },
    draw: function(point){
      var cls;
      this.point = point;
      if (!this.repr) {
        cls = this.decideRepr();
        this.repr = new cls(_.extend(this.inherit(), {
          gameview: this.gameview,
          state: this.state
        }));
      }
      console.log(this.name, "DRAW", this.repr.name, this.point.coords());
      return this.repr.draw.call(this.repr, this.point);
    },
    decideRepr: function(){
      throw 'override me';
    }
  });
  DirectionPainter = exports.DirectionPainter = MetaPainter.extend4000({
    decideRepr: function(){
      return this.reprs[(this.state.direction || this.state.get('direction')).string()];
    }
  });
  OrientationPainter = exports.OrientationPainter = MetaPainter.extend4000({
    decideRepr: function(){
      return this.reprs[this.state.get('direction').orientation()];
    }
  });
}).call(this);
